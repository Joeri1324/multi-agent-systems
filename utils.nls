;THIS IS A FILE WHERE WE STORE UTILS

to-report shortest-path [bs1 bs2]
  if bs1 = bs2 [ 
    let idx [who] of bs1
    report (list idx)
  ]
  let backpointers item 0 (item [who] of bs1 distances)
  let node_pointer [who] of bs2
  let full_path []
  set full_path lput [who] of bs2 full_path
  while [array:item backpointers node_pointer != [who] of bs1] [
    set node_pointer (array:item backpointers node_pointer)
    set full_path lput node_pointer full_path
  ]
  set full_path lput [who] of bs1 full_path
  report reverse full_path
end

to-report dijkstra [vertexFrom]
  let Q  n-values 24 [?]
  let S []
  
  let dist array:from-list n-values length graph [1000000] ; should be infinity but large number will work
  let prev array:from-list n-values length graph [0] ;
  
  array:set dist vertexFrom 0
  
  while [length Q != 0] [
    ; let l filter [not member? ? S] Q
    ; print l
    let v one-of Q
    
    foreach Q [ ; find lowest distance which is not visited yet
      if array:item dist ? < array:item dist v [
         set v ?
      ]
    ]
    set Q remove v Q
    ; set S lput v S ; add u to visited nodes
    
    let adjacent item v graph
    foreach adjacent [
      if (array:item dist v + get-distance ? v) < array:item dist ? [
        array:set dist ? array:item dist v + get-distance ? v
        array:set prev  ? v
      ]
    ]
  ]
 
  let result []
  set result lput prev result
  set result lput dist result
  report result
end

;function which takes in a bus stop id and returns a list corresponding to how many passengers
;at the bus stop want to go to each of the 24 destinations
to-report where-are-passengers-at-stop-going [bs_id]
  ;initialising the output list
  let destinations []
  repeat 24 [ set destinations lput 0 destinations ]
  
  ;getting a list of the passengers at the stop
  let passenger_list get-passengers-at-stop bs_id
  foreach passenger_list [ 
    let passenger_destination item 1 ?
    set destinations replace-item passenger_destination destinations ((item passenger_destination destinations) + 1)
  ]
  report destinations
end

;function which takes in a bus (the actual turtle) and returns a list corresponding to how many passengers
;on the bus want to go to each of the 24 destinations
to-report where-are-passengers-on-bus-going [bus]
  let destinations []
  repeat 24 [ set destinations lput 0 destinations ]
  foreach bus_passengers [
    let passenger_destination item 1 ?
    set destinations replace-item passenger_destination destinations ((item passenger_destination destinations) + 1)
  ]
  report destinations
end

;path is represented as a list of bus_stop ids (e.g. [ 3 4 5 16 ])
to-report length-of-path [ path ]
  let pairwise_lengths []
  foreach n-values (length path - 1) [?] [
    set pairwise_lengths lput (get-distance item ? path item (? + 1) path) pairwise_lengths
  ]
  report sum pairwise_lengths
end

;__________________________________________________________-
;utils from Joeri's branch

to-report get-destination [passenger]
  report item 1 passenger
end

to-report argmax [l]
  report reduce [ifelse-value (item ?1 l > item ?2 l) [?1] [?2]] n-values length graph [?]
end

to-report bincount-destinations [destinations]
  let counts n-values length graph [0]
  foreach destinations [
    set counts replace-item ? counts ((item ? counts) + 1)
  ]
  report counts
end 

to-report get-destination-most-passenger
  let counts bincount-destinations reduce sentence n-values length graph [map get-destination get-passengers-at-stop ?]
  ; set already desired stop to zero
  foreach filter [? != -1] get-all-desires [set counts replace-item ? counts 0]
  report argmax counts
end

to-report get-stops-waiting-passenger-who-want-to-go-to [bus_stop]
  report filter [? != -1 ] map [ifelse-value member? bus_stop (map get-destination get-passengers-at-stop ?) [?] [-1]] n-values length graph [?]
  ; report n-values length graph [map [ifelse-value (get-destination ? = bus_stop) [?1] [0]] get-passengers-at-stop ?1]
end

; this should be done by messages
to-report get-all-desires
  let desires []
  ask buses [
    set desires lput desire desires
  ]
  report desires
end