__includes [ "utils.nls" ]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop). 
  
  bus_size
  distances
  desire
  intention
  long_term_route
  long_term_route_index
]

globals [graph]

to init-buses
  set bus_size int item (bus_type - 1) [12 60 150]
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
   ; Distance array, e.g. "distances 2 7" is the shortest path distance from bus stop 2 to bus stop 7
  set distances n-values length graph [dijkstra ?] 
  set desire -1
  set intention -1
  
end

to-report get-destination [passenger]
  report item 1 passenger
end

to-report argmax [l]
  report reduce [ifelse-value (item ?1 l > item ?2 l) [?1] [?2]] n-values length graph [?]
end

to-report bincount-destinations [destinations]
  let counts n-values length graph [0]
  foreach destinations [
    set counts replace-item ? counts ((item ? counts) + 1)
  ]
  report counts
end 

to-report get-destination-most-passenger
  let counts bincount-destinations reduce sentence n-values length graph [map get-destination get-passengers-at-stop ?]
  ; set already desired stop to zero
  foreach filter [? != -1] get-all-desires [set counts replace-item ? counts 0]
  report argmax counts
end

to-report get-stops-waiting-passenger-who-want-to-go-to [bus_stop]
  report filter [? != -1 ] map [ifelse-value member? bus_stop (map get-destination get-passengers-at-stop ?) [?] [-1]] n-values length graph [?]
  ; report n-values length graph [map [ifelse-value (get-destination ? = bus_stop) [?1] [0]] get-passengers-at-stop ?1]
end

; right now pretend that there is only one bus
to set-desire
  if desire = -1 [set desire get-destination-most-passenger]
  if desire = current_stop [
    set desire -1
  ]
end

to-report get-route [bs1 bs2]
  let backpointers item 0 (item bs1 distances)
  let node_pointer  bs2
  let full_path []
  set full_path lput bs2 full_path
  while [array:item backpointers node_pointer != bs1] [
    set node_pointer (array:item backpointers node_pointer)
    set full_path lput node_pointer full_path
  ]
  report reverse full_path
end 

; RANDOM! Should have tsp implementation for shortest 
to-report calculate-route [bs_stops]
  if bs_stops = [] [set bs_stops item current_stop graph] ; go to centraal
  let first_stop item 0 bs_stops
  let stops lput desire bs_stops
  let previous current_stop
  
  let result []
  foreach stops [
    set result reduce sentence fput result get-route previous ?
    set previous ?
  ]
  report  result  
end

; this should be done by messages
to-report get-all-desires
  let desires []
  ask buses [
    set desires lput desire desires
  ]
  report desires
end
  

; intention 2 means go directly to desire because bus is full
to set-intention 
  if length bus_passengers = bus_size [set intention 2]
  ; if current_stop = desire [set intention -1]
end

to act-on-intention 
  if desire != -1 [
    let bs_stops get-stops-waiting-passenger-who-want-to-go-to desire
    print "desire"
    print desire
    print intention
    print get-stops-waiting-passenger-who-want-to-go-to desire
    print current_stop
    let route calculate-route desire
    set long_term_route route
    set long_term_route_index 0
    set intention 1   ; is mutated here which is not desired
  ]
  if intention = 2 and current_stop != -1 [
    set long_term_route get-route current_stop desire
  ]
end

to navigate 
  if current_stop = desire or desire = -1 [
    set desire get-destination-most-passenger
    let bs_stops get-stops-waiting-passenger-who-want-to-go-to desire
    set long_term_route calculate-route bs_stops
  ]
end
  
to travel 
  ; implementing it like this might take an extra tick after every route
  if desire != -1 [
    travel-to item 0 long_term_route
  ]
end

to remove-current-stop-from-path
  if current_stop = item 0 long_term_route [
    set long_term_route remove-item 0 long_term_route
  ]
end

to pick-up-passengers
  if current_stop != -1 [
    foreach filter [get-destination ? = desire] get-passengers-at-stop current_stop [
      if length bus_passengers != bus_size [pick-up-passenger item 0 ?]
    ]
  ]
end

to drop-off-passengers 
  foreach bus_passengers [
    if current_stop = get-destination ? [
      drop-off-passenger item 0 ?
    ]
  ]
end

to make-new-buses
  if bus_id = 24 [ 
      if ticks >= 10 and ticks <= 15 [ 
        ifelse ticks >= 10 and ticks <= 13 [ add-bus 3 ] [ add-bus 2 ]
      ]
  ]
end

to execute-actions
  make-new-buses
  navigate
  travel
  pick-up-passengers
  drop-off-passengers
  remove-current-stop-from-path
end