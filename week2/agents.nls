extensions [array table]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  added-bus
  destination     ; 
]
 
globals [graph]

to init-buses
  set added-bus 0
  ; Initialize your agents here.
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
end

to-report min-positions [my-list]
  let min-value min my-list
  let indices n-values (length my-list) [?]
  report filter [item ? my-list = min-value] indices
end 

to-report dijkstra [vertexFrom]
  let Q reduce sentence graph
  set Q remove-duplicates Q
  let S []
  
  let dist array:from-list n-values length graph [1000000] ; should be infinity but large number will work
  let prev array:from-list n-values length graph [0] ;
  
  array:set dist vertexFrom 0
  
  while [length Q != 0] [
    ; let l filter [not member? ? S] Q
    ; print l
    let v one-of Q
    
    foreach Q [ ; find lowest distance which is not visited yet
      if array:item dist ? < array:item dist v [
         set v ?
      ]
    ]
    set Q remove v Q
    ; set S lput v S ; add u to visited nodes
    
    let adjacent item v graph
    foreach adjacent [
      if (array:item dist v + get-distance ? v) < array:item dist ? [
        array:set dist ? array:item dist v + get-distance ? v
        array:set prev  ? v
      ]
    ]
  ]
  let result []
  set result lput prev result
  set result lput dist result
  report result
end

to-report get-route [prev]
  print prev
  print destination
  let new_path destination
  while [array:item prev new_path != current_stop] [
    print new_path
    set new_path (array:item prev new_path)

  ]
  report new_path
end

to execute-actions
  print destination
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  let at_bus_stop current_stop != -1
  
  let bus_full 0
  if length bus_passengers = 12 and bus_type = 1  [
    set bus_full 1
  ]
  if length bus_passengers = 60 and bus_type = 2 [
    set bus_full 1
  ]
  if length bus_passengers = 150 and bus_type = 3  [
    set bus_full 1
  ]
  
  if bus_full = 1 [
    add-bus 0
  ]
  
  ifelse at_bus_stop [
    let passengers_at_stop get-passengers-at-stop current_stop
    
    let prev_dist dijkstra current_stop
    
    let dist item 1 prev_dist;
    let prev item 0 prev_dist;
    
    foreach passengers_at_stop [    ; should change to not pick up everyone
      let passenger_id item 0 ? 
      if bus_full = 0 [
        pick-up-passenger passenger_id
      ]
    ]
    
    foreach bus_passengers [
      let desired_stop item 1 ?
      let passenger_id item 0 ?
      if desired_stop = current_stop [
        drop-off-passenger passenger_id
      ]
    ]
    
   
    if current_stop = destination [
      set destination 0
    ]
   
    let min_destination random 24
    print length  bus_passengers
    if length bus_passengers > 0 [
     set min_destination  item 1 (one-of bus_passengers)  
    ]
    
    print "minnnn"
    print min_destination
    if destination = 0 [   ; have to set new destination
      foreach bus_passengers [
        let desired_stop item 1 ?
        if array:item dist desired_stop < array:item dist min_destination [
          set min_destination desired_stop
        ]  
      ] 
      set destination min_destination
    ]
    travel-to get-route prev
  ]
  [
    travel-to next_stop
  ]
end