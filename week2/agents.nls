extensions [array table]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  added-bus
  destination     ; 
  destination_route
  distances
]
 
globals [graph]

to init-buses
  set added-bus 0
  ; Initialize your agents here.
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  set distances n-values length graph [dijkstra ?]
  set destination_route []
end

to-report min-positions [my-list]
  let min-value min my-list
  let indices n-values (length my-list) [?]
  report filter [item ? my-list = min-value] indices
end 

to-report dijkstra [vertexFrom]
  let Q  n-values 24 [? ]
  let S []
  
  let dist array:from-list n-values length graph [1000000] ; should be infinity but large number will work
  let prev array:from-list n-values length graph [0] ;
  
  array:set dist vertexFrom 0
  
  while [length Q != 0] [
    ; let l filter [not member? ? S] Q
    ; print l
    let v one-of Q
    
    foreach Q [ ; find lowest distance which is not visited yet
      if array:item dist ? < array:item dist v [
         set v ?
      ]
    ]
    set Q remove v Q
    ; set S lput v S ; add u to visited nodes
    
    let adjacent item v graph
    foreach adjacent [
      if (array:item dist v + get-distance ? v) < array:item dist ? [
        array:set dist ? array:item dist v + get-distance ? v
        array:set prev  ? v
      ]
    ]
  ]
 
  let result []
  set result lput prev result
  set result lput dist result
  report result
end

to-report waiting-passenger-cost [vertex waiting-passenger]
  if length waiting-passenger = 0 [
    report 0
  ]
  report reduce + map [ array:item (item 1 (item vertex distances)) (item 1 ?)] waiting-passenger   ; have to check if 1 is indeed the destination index
end  
  
to-report nameless [vertexFrom waiting-passengers]
  let Q  n-values 24 [? ]
  let S []
  
  let dist array:from-list n-values length graph [1000000] ; should be infinity but large number will work
  let prev array:from-list n-values length graph [0] ;
  
  array:set dist vertexFrom 0
  
  while [length Q != 0] [
    ; let l filter [not member? ? S] Q
    ; print l
    let v one-of Q
    
    foreach Q [ ; find lowest distance which is not visited yet
      if array:item dist ? < array:item dist v [
         set v ?
      ]
    ]
    set Q remove v Q
    ; set S lput v S ; add u to visited nodes
    
    let adjacent item v graph
    foreach adjacent [
      let cost array:item dist v + waiting-passenger-cost ? waiting-passengers
      if cost < array:item dist ? [
        array:set dist ? cost
        array:set prev ? v
      ]
    ]
  ]

  let result []
  set result lput prev result
  set result lput dist result
  report result
end
  
to-report get-route [prev]
  let new_path destination
  let full_path []
  set full_path lput new_path full_path
  while [array:item prev new_path != current_stop] [
    set new_path (array:item prev new_path)
    set full_path lput new_path full_path
  ]
  let result []
  set result lput new_path result
  set result lput full_path result
  report result
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  let at_bus_stop current_stop != -1
  
  let capacity item (bus_type - 1) [12 60 150]
  if length bus_passengers = capacity and added-bus = 0 [
    add-bus (random 2) + 1
    set added-bus 1
  ]
  
  ifelse at_bus_stop [
    let passengers_at_stop get-passengers-at-stop current_stop
    
    let prev_dist nameless current_stop passengers_at_stop
    
    let dist item 1 prev_dist;
    let prev item 0 prev_dist;

    foreach bus_passengers [
      let desired_stop item 1 ?
      let passenger_id item 0 ?
      if desired_stop = current_stop [
        drop-off-passenger passenger_id
      ]
    ]
    
   
    if current_stop = destination [
      set destination 0
    ]
   
    let min_destination random 24
   
    if destination = 0 [   ; have to set new destination
      foreach passengers_at_stop [
        let desired_stop item 1 ?
        if array:item dist desired_stop < array:item dist min_destination [
          set min_destination desired_stop
        ]  
      ] 
      set destination min_destination
    ]
    
    let next_path_full_path get-route prev 
    set destination_route item 1 next_path_full_path
    
    foreach passengers_at_stop [    ; should change to not pick up everyone
      let passenger_id item 0 ? 
      let dest item 1 ?
      if length bus_passengers != capacity and member? dest destination_route  [
        pick-up-passenger passenger_id
      ]
    ]
    
    travel-to item 0 next_path_full_path
  ]
  [
    travel-to next_stop
  ]
end