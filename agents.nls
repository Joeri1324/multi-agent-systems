__includes [ "utils.nls" ]
extensions [array]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.

  possible_next_stops ; List containing all possible next stops (i.e. list of bus_stop turtles) from the current_stop (if current stop is -1,
                      ; possible_next_stops will be applied to the previous stop
  long_term_path ; List containing the route the bus is taking for the next few moves
  next_intended_stop ; a next_stop style variable that we are allowed to modify

  distances ;  
  beliefs;
  desires;
  intentions;
  
  route_path;
  mode;
  score; number of passengers the bus has dropped off at their final destination (or something like this)
]
 
globals [graph]

to init-buses
  ; Initialize your agents here.
  set long_term_path []
  set next_intended_stop 9
  set score 0
  set mode random 2
  set route_path []
  repeat 24 [ set route_path lput [] route_path ]
  set route_path replace-item 9 route_path [8]
  set route_path replace-item 8 route_path [9 2 6]
  set route_path replace-item 2 route_path [8]
  set route_path replace-item 6 route_path [8]
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  set distances n-values length graph [dijkstra ?] 
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  
  ;adding new buses at time intervals 
  make-new-buses
  
  ;checking if the bus is at a stop
  if current_stop >= 0 [ 
    
    let beneficial_destinations destinations-that-should-be-on-bus self
    
    ;dropping off any passengers who want to be at the stop
    drop-off-correct-passengers
    
    if mode = 0 [
      move-along-route route_path
    ]
    
    if mode = 1 [ 
      spillover-actions self
    ]
    
    ;dropping off passengers who won't benefit from staying on the bus
    foreach bus_passengers [ 
      if not member? item 1 ? beneficial_destinations [
        drop-off-passenger item 0 ?
      ]
    ]
    
    ;picking up passengers who would benefit from getting on the bus
    let passengers_here get-passengers-at-stop current_stop
    foreach passengers_here [
      if not has-reached-capacity? self [
        if member? item 1 ? beneficial_destinations [
        pick-up-passenger item 0 ?
        ]
      ]
    ]
  ]
  ;travelling to the next stop
  if bus_id != 24 and ticks mod 15 = 0 [ 
  send-message 24 long_term_path
  ]
  travel-to next_intended_stop         
end

;_________________________________________________________________________________________________

;_________________________________________________________________________________________________


to move-along-route [ dummy_route_path ]
  let stops_involved_in_route []
  foreach n-values (length dummy_route_path) [?] [
    if item ? dummy_route_path != [] [
      set stops_involved_in_route lput ? stops_involved_in_route
    ]
  ]
  ifelse member? current_stop stops_involved_in_route [
    set long_term_path stops_involved_in_route
    let next_stops item current_stop dummy_route_path
    let max_passengers_waiting -1
    let busiest_stop -1
    if length next_stops > 1 [ set next_stops remove previous_stop next_stops ]
    foreach next_stops [ 
      let num_passengers_waiting length get-passengers-at-stop ?
      if num_passengers_waiting > max_passengers_waiting [ 
        set max_passengers_waiting num_passengers_waiting
        set busiest_stop ?   
      ]
    ]
    set next_intended_stop busiest_stop
  ]
  
  [
    set long_term_path shortest-path bus_stop current_stop bus_stop one-of stops_involved_in_route
    set next_intended_stop item 1 long_term_path
  ]
end

to drop-off-correct-passengers
  foreach bus_passengers [ 
      if item 1 ? = current_stop [ 
        drop-off-passenger item 0 ? 
      ] 
    ]
end

;FUNCTION which calculates whether being picked up by a bus will move a passenger closer to its destination
;INPUT; the bus itself
;OUTPUT;Boolean value
to-report benefits-passenger-to-be-on-bus? [ bus passenger_destination ]
  let current_distance_from_destination length-of-path (shortest-path bus_stop current_stop bus_stop passenger_destination)
  
  foreach long_term_path [ 
    let distance_from_destination length-of-path (shortest-path bus_stop ? bus_stop passenger_destination)
    if distance_from_destination < current_distance_from_destination [
      report true ]
  ]
  report false
end

to-report destinations-that-should-be-on-bus [ bus ]
  let destinations_list []
  foreach n-values 24 [?] [
    let possible_destination ?
    let current_distance_from_destination length-of-path (shortest-path bus_stop current_stop bus_stop possible_destination)
    let is_benefit false
    foreach long_term_path [
      let distance_from_destination length-of-path (shortest-path bus_stop ?1 bus_stop possible_destination)
      if distance_from_destination < current_distance_from_destination [
        set is_benefit true
      ]
    ]  
    if is_benefit [ 
      set destinations_list lput ? destinations_list
    ]
  ]
  report destinations_list
end

to make-new-buses
  if bus_id = 24 [ 
      if ticks >= 0 [ 
        if ticks mod 50 = 0 [ 
          add-bus (3)
        ]
      ]
  ]
end

;________________________________________________________________________________________________

to spillover-actions [bus]
  if length long_term_path = 0 or length bus_passengers = 0 [
    set long_term_path n-values 24 [?]
  ]
;    ;picking up passengers with destinations on the route (until bus is full)
;    let available_passengers get-passengers-at-stop current_stop
;    foreach available_passengers [ 
;      if not has-reached-capacity? self [
;        if not is-number? long_term_path [
;          if member? bus_stop item 1 ? long_term_path [
;            pick-up-passenger item 0 ?
;          ]
;        ]
;      ]
;    ]
    
    ;getting a list of the possible next stops
    set possible_next_stops (sort [link-neighbors] of bus_stop current_stop)
      
    ;picking one of these at random  
    let random_index random length possible_next_stops
    let selected_stop (item random_index possible_next_stops)
    set next_intended_stop ([who] of selected_stop)
    
    ;choosing the path based on where the passengers want to go
    let passenger_wishes where-are-passengers-on-bus-going self
    let majority_preference 0
    let majority_destination -1
    let index n-values 24 [?]
    foreach index [
      if item ? passenger_wishes > majority_preference [ 
        set majority_preference item ? passenger_wishes
        set majority_destination ? 
      ]
    ]    
    if majority_destination != -1 [ 
      set long_term_path shortest-path (bus_stop current_stop) (bus_stop majority_destination)
      set long_term_path but-first long_term_path
      if length long_term_path > 0 [ 
        set next_intended_stop (item 0 long_term_path)
      ] 
    ]
    if next_intended_stop = 8 and current_stop = 9 [
      set next_intended_stop item (random 2) [ 3 20 ]
      foreach bus_passengers [
        let destination item 1 ?
        if destination = 8 or destination = 6 or destination = 2 [
          drop-off-passenger item 0 ?
        ]
      ]
    ]
    if current_stop = 9 [
      let available_passengers get-passengers-at-stop current_stop
      foreach available_passengers [ 
        let destination item 1 ?
        if not has-reached-capacity? self [ 
          if destination != 8 and destination != 6 and destination != 2 [
            pick-up-passenger item 0 ?
          ]
        ]
      ]
    ]
end

;__________________________________________________________________________________________________________________________________________

