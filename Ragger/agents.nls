__includes["utils.nls"]
extensions [array table]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  capacity
  added_bus
  dijkstra_out
  upcoming_stop
  flags
  travel_along
  max_buses
]
 
globals [graph]

to init-buses
  set capacity int item (bus_type - 1) [12 60 150]
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  set dijkstra_out n-values length graph [dijkstra ?]
  set flags n-values length graph [which-stop-better ?]
  set added_bus 0
  set max_buses 40
end

to execute-actions
  
  make-new-bus
 
  ; Check if at bus stop
  let at_bus_stop current_stop != -1
  
  if at_bus_stop [
    
    let passengers_total sentence get-passengers-at-stop current_stop bus_passengers
    
    ifelse length passengers_total = 0 [
      find-passengers ;
    ][
      listen-to-passengers passengers_total
    ]
    
    drop-off-passengers
    pick-up-passengers
    
  ] 
  
  travel-to upcoming_stop
  
end

to drop-off-passengers
     ; Drop off traveling passengers
    foreach bus_passengers [
      let passenger_destination item 1 ?
      if not (item passenger_destination travel_along)[
        drop-off-passenger item 0 ?
      ]
    ]
end

to pick-up-passengers
; Pick up waiting passengers
    foreach get-passengers-at-stop current_stop [
      let passenger_destination item 1 ?
      if (item passenger_destination travel_along and length bus_passengers < capacity)[
        pick-up-passenger item 0 ?
      ]
    ]
end

; Create new buss
to make-new-bus
  if count buses < max_buses and added_bus = 0 [
    add-bus 2
    set added_bus 1
  ]
end

; Reports a list containing a list for each adjacent stop in which each destination is flagged as better/closer "true" or worse "false"
to-report which-stop-better [bs]
  let current_distances n-values length graph [distance-from-to bs ?]
  let next_flags []
  foreach item bs graph[
    let distances distance-to-destinations ?
    let bs_flags (map [?1 - ?2 > 0] current_distances distances)
    set next_flags lput bs_flags next_flags
  ]
  report next_flags
end

; Let passengers vote which next stop to go to
; Reports the number of the next stop with the highest passenger vote  
to-report vote-next-stop [current_bs people next_flags]
  let winning_stop -1
  let highest_vote -1
  foreach n-values length next_flags [?] [
    let vote count-votes people item ? next_flags
    if vote > highest_vote [
      set highest_vote vote
      set winning_stop ?
    ]
  ]  
  report item winning_stop (item current_bs graph)      
end

; Reports the vote count for one destination 
to-report count-votes [people stop_flags]
  report reduce + map [ifelse-value (item (item 1 ?) stop_flags) [1] [0]] people
end

; Function that is called instead of listening to the passengers
; Randomly drives to one of the next stops to look for passengers
; (this function should be improved to go in the direction of crowded stops)
to find-passengers
  set upcoming_stop one-of item current_stop graph
end

; Reports the distances from a given bus stop to all possible destinations  
to-report distance-to-destinations [bs]
  report n-values length graph [distance-from-to bs ?]  
end

; Reports the distance between two stops precalculated with Dijkstra's algorithm
to-report distance-from-to [bs1 bs2]
    report array:item (item 1 (item bs1 dijkstra_out)) bs2
end

; Function that will decide the next stop based on passenger votes (called when arrived at a bus stop)
to listen-to-passengers [people]
  let next_flags item current_stop flags
  set upcoming_stop vote-next-stop current_stop people next_flags
  set travel_along item (position upcoming_stop (item current_stop graph)) next_flags
end



