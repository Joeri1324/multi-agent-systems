__includes["utils.nls"]
extensions [array table]

buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  coordinator_bus
  interval
  dijkstra_out
  upcoming_stop
  flags
  buses_needed
  fabrication_orders
  possible_destinations
  destination
  obedience
  path
  most_people_at_stop
  passenger_counts
  last_mean_passenger_count
  bus_type_consensus
  
]
 
globals [graph]

to init-buses
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  set dijkstra_out n-values length graph [dijkstra ?]
  set flags array:from-list (n-values length graph [which-stop-better ?])
  set coordinator_bus 24 ; should be the first bus to coordinate new buses
  set fabrication_orders ifelse-value (bus_id = coordinator_bus) [1][0]
  set interval 15 ; e.g. 5, 10, 15, 30, 60
  set buses_needed 12 ; (coordinator)
  set obedience 0.9 ; (parameter to tune) 0 = never listen to local passengers, 1 = always listen to local passengers
  set possible_destinations remove current_stop n-values length graph [?]
  set destination -1
  set path []
  set passenger_counts [] ; (coordinator) list that will contain the global waiting passengers for each tick
  set last_mean_passenger_count amount_passengers_waiting (coordinator); last mean of passenger_counts
  set most_people_at_stop 0 ; Highest number of passengers the bus has encountered so far
  set bus_type_consensus 2 ; Consensus of what type the buses to add should be of
end

to execute-actions
  
  ; Update and vote every -interval- ticks
  if ticks mod interval = 0 [
    vote-bus-type
  ]
  
  ; Coordinator bus shares the voted bus_type consensus and bus_limit to other buses
  if bus_id = coordinator_bus [
    if ticks mod interval = 1 [
      share-info
    ]
    ; Keep track of global passenger counts
    set passenger_counts lput amount_passengers_waiting passenger_counts
  ]
  
  ; Update the bus type consensus
  if ticks mod interval = 2 and bus_id != coordinator_bus [
    update-info
  ]
  
  make-new-bus bus_type_consensus
 
  ; Check if at bus stop
  let at_bus_stop current_stop != -1
  
  if at_bus_stop [
    
    update-destinations
    
    let local_passengers sentence get-passengers-at-stop current_stop bus_passengers
    if length local_passengers > most_people_at_stop [set most_people_at_stop length local_passengers]
     
    ifelse (is-obedient local_passengers) [
      listen-to-passengers local_passengers
    ][
      pick-rare-destination
      head-to-destination
    ]

    let travel_along array:item (array:item flags current_stop) (position upcoming_stop (item current_stop graph))
    
    drop-off-passengers travel_along
    pick-up-passengers travel_along
    
    
  ] 
  
  travel-to upcoming_stop
    
end

to drop-off-passengers [travel_along]
     ; Drop off traveling passengers
    foreach bus_passengers [
      let passenger_destination item 1 ?
      if not (array:item travel_along passenger_destination)[
        drop-off-passenger item 0 ?
      ]
    ]
end

to pick-up-passengers [travel_along]
; Pick up waiting passengers
    foreach get-passengers-at-stop current_stop [
      let passenger_destination item 1 ?
      if (length bus_passengers < capacity bus_type and array:item travel_along passenger_destination)[
        pick-up-passenger item 0 ?
      ]
    ]
end

; Send vote of bus type preference to coordinator bus
to vote-bus-type 
  send-message coordinator_bus list "vote bus type" (ifelse-value (most_people_at_stop < 60) [2][3])
  set most_people_at_stop 0
end


; Check if the last inbox message was recently sent, and update accordingly
to update-info
  if length inbox > 0 [
    let last_update last filter [first item 2 ? = "updates"] inbox
    set bus_type_consensus item 1 item 2 last_update
    set fabrication_orders fabrication_orders + item 2 item 2 last_update
  ]
end

; (Coordinator bus function)
; Determine bus limit based on waiting passenger increment and the chosen passengers_per_bus parameter
to-report determine-buses-needed
  let increment last_mean_passenger_count - mean passenger_counts
  set passenger_counts []
  if increment > 0 [
    report round (increment / capacity bus_type_consensus)
  ]
  report 0
end

; (Coordinator bus function)
; Report the consensus of the bus_type based on the votes
to-report consensus-of-votes
  let new_messages filter [first ? = ticks - 1 and first item 2 ? = "vote bus type"] inbox
  let votes map [item 1 item 2 ?] new_messages
  let vote_counts map [occurrences ? votes][2 3]
  report ifelse-value (item 0 vote_counts > item 1 vote_counts) [2][3]
end

; (Coordinator bus function)
; Ask for more bus support by dividing the amount of buses that need to be fabricated over the other buses
to share-info
  set bus_type_consensus consensus-of-votes
  set buses_needed (buses_needed + determine-buses-needed)
  let fabricators determine-fabricators
  foreach [bus_id] of other buses [
    send-message ? (list "updates" bus_type_consensus occurrences ? fabricators)
  ]    
end

; (Coordinator bus function)
; Randomly pick a set of existing agents to make the amount of new buses required
to-report determine-fabricators
  let fabricators []
  while [buses_needed > 0] [
    let fabricator one-of [bus_id] of other buses
    set fabricators lput fabricator fabricators
    set buses_needed buses_needed - 1
  ]
  report fabricators
end
  
; Create new buss
to make-new-bus [carry_type]
  if fabrication_orders > 0 [
    add-bus carry_type
    set fabrication_orders fabrication_orders - 1
  ]
end

; Updates the destination if arrived and possible destinations to visit
to update-destinations
  set possible_destinations remove current_stop possible_destinations
  if current_stop = destination [
    set destination -1
  ]
  if possible_destinations = [] [
    set possible_destinations remove current_stop n-values length graph [?]
  ]
end

; Reports if the bus is going to listen to the local passengers' next stop wishes or not  
to-report is-obedient [local_passengers]
  let obedient false
  if random-float 1 < obedience [set obedient true]
  if length local_passengers = 0 [set obedient false]
  if length path > 0 [set obedient false]
  report obedient 
end  

; Reports a list containing a list for each adjacent stop in which each destination is flagged as better/closer "true" or worse "false"
to-report which-stop-better [bs]
  let current_distances distance-to-destinations bs
  let adjacent_stops item bs graph
  let next_flags array:from-list n-values length adjacent_stops [0]
  foreach n-values length adjacent_stops [?] [
    let distances distance-to-destinations item ? adjacent_stops
    let bs_flags array:from-list (map [?1 - ?2 > 0] current_distances distances)
    array:set next_flags ? bs_flags
  ]
  report next_flags
end

; Reports the number of the next stop with the highest passenger vote  
to-report vote-next-stop [current_bs travelers next_flags]
  let winning_index (reduce [ifelse-value (count-votes travelers array:item next_flags ?2 > count-votes travelers array:item next_flags ?1) [?2] [?1]] n-values array:length next_flags [?])
  report item winning_index (item current_bs graph)     
end

; Reports the vote count for one destination 
to-report count-votes [travelers stop_flags]
  report (reduce + map [ifelse-value (array:item stop_flags (item 1 ?)) [1] [0]] travelers)
end

; Pick a new destination if needed
to pick-rare-destination 
  if destination = -1 [ 
    set destination one-of possible_destinations
    set path remove current_stop shortest-path current_stop destination 
  ]  
end

; Continue along the path towards the destination   
to head-to-destination  
  if path != [] [
    set upcoming_stop first path
    set path remove first path path
  ]
end  

; Drive randomly to one of adjacent stops (NOT USED CURRENTLY)
to drive_randomly
  set upcoming_stop one-of item current_stop graph
end

; Reports the distances from a given bus stop to all possible destinations  
to-report distance-to-destinations [bs]
  report n-values length graph [distance-from-to bs ?]  
end

; Reports the distance between two stops precalculated with Dijkstra's algorithm
to-report distance-from-to [bs1 bs2]
    report array:item (item 1 (item bs1 dijkstra_out)) bs2
end

; Function that will decide the next stop based on passenger votes (called when arrived at a bus stop)
to listen-to-passengers [travelers]
  let next_flags array:item flags current_stop 
  set upcoming_stop vote-next-stop current_stop travelers next_flags
end

to-report capacity [type_of_bus]
  report item (type_of_bus - 1) [12 60 150]
end  



